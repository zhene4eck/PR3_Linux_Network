# Сети в Linux

## В этом проекте поставлена задача: настроить сети в Linux на виртулаьной машине.

### В рамках задачи изучается:
- Стек протоколов TCP IP
- Адресация
- Маршрутизация


## 1. Стек протоколов TCP IP

Сеть - соединеие компьютеров (2 или более) с помощью каналов связи или оборудования. Данные между компьютерами передаются (по каналам/оборудоваию) с помощью правил. Эти правила задаются стеком протоколов TCP IP. 

## 1.1. Stack
Stack – способ линейной организации данных по принципу last in first out, LIFO или «последним пришёл, первым вышел» (добавлять новые элементы и удалять существующие можно только с вершины). Чем выше элемент находится в пирамиде, тем раньше его заберут. Этим стеки отличаются от очереди (queue) — структуры данных, где первым используется элемент, который появился раньше всех.

### Команды, которые можно использовать со стеками:

- push — добавляет элемент на вершину стека.
- pop — удаляет элемент с вершины стека.
- peek — считывает элемент с вершины стека без его удаления.
- isEmpty — проверяет, пуст ли стек.
- size — возвращает количество элементов в стеке.

### Как используем:
- Реализация отмены. Можем отменить последнее созданное действие в графическом и текстовом редакторе без подъема всей цепочки последоватености (всей хронологии).
- Хранит информацию о вызовах функций и локальных переменных.
- Управление операциями в базах данных.
- Для управления вызовами системных функций и передачей параметров между приложениями и ядром операционной системы.
- Для вычисления выражений, проверки скобок и выполнения других операций.

### Реализация стека:

- С помощью динамического массива – размер которого может увеличиваться или уменьшаться в процессе выполнения программы. Операции добавления (push) и удаления (pop) элементов производятся либо с конца, либо с начала массива. Используется при фиксированном размере и нечастых изменениях стека.

- С помощью связных списков – каждый узел содержит какие-то данные и указатель на предыдущий узел. При добавлении новый элемент становится вершиной стека, а при удалении на вершине оказывается предыдущий элемент. Используем в случае, когда не знаем максимальную величину или хотим часто менять размер стека.

### Стек вызовов:

Стек вызовов — это структура данных, которая управляет вызовами функций во время выполнения программы. Когда компьютер выполняет функцию, и ему нужно переключиться на следущую, он записывает в стек точки перехода (начения переменных, аргументы функций и адрес возврата — то место, куда компьютер должен перейти после окончания подпрограммы). Когда функция выполнена, программа считывает точку перехода (адрес возврата) в стеке, удаляет ее и переходит к основной программе, выполняя ее.

### Переполение стека:

- Рекурсия большой глублины вложенности влияет на аварийное завершение работы (Python до 3000 вызовов).
- Бесконенчые циклы:

      def infinite_loop():
          while True:
              pass
      Вызываем бесконечный цикл
      infinite_loop()

### Стек данных:

Этот вид стеков часто используют для работы с разветвлёнными типами данных: деревьями, графами, XML-документами, JSON-объектами и другими.
Древо: в этом случае мы начинаем с корня и идём так глубоко, как только можем, а потом возвращаемся, чтобы исследовать другую ветвь. И стеки подходят для этого как нельзя лучше:

- Когда мы посещаем узел, мы добавляем его в стек.
- Когда мы хотим вернуться к предыдущему узлу, мы достаём его из стека.

## 1.2. Transmission Control Protocol/Internet Protocol

### **Transmission Control Protocol/Internet Protocol (TCP IP)** – стек протоколов, которые задают правиа: 

**TCP (Transmission Control Protocol)** отвечает за обмен данными. Он управляет их отправкой и следит за тем, чтобы они дошли до получателя в целости.
**IP (Internet Protocol)** отвечает за адресацию. Его задача — связывать друг с другом устройства и нарезать данные на пакеты для удобной отправки. 
Эти два протокола работают в связке: IP строит маршрут, а TCP контролирует, чтобы всё передавалось правильно.

### 7 уровней модели OSI:

Каждый протокол описывает строго ему отведенный набор правил. Также протоколы разделены по уровням функциональности (по модели сетевого взаимодействия OSI - 7 уровней). 
Модель OSI спускеются вниз от прикладного до физического уровня, передает инфомацию на другой компьютер, после подниматся обратно (на компьютере получателя и отправителя). Сначало идет шифрование и передача, а после на компьютере отправителя и получаетля расшифрование информации.

7. Прикладной (Application) layer: Обеспечивает интерфейс между пользователем и сетью (например, картинка, которую мы хотим отправить), работает с приложениями (протоколы HTTP, FTP, SMTP, DNS).

Данный уровень позволяет смотреть и пользоваться (серфить) информацией. Представлен сетевым интерфейсом (протоколы HTTP, FTP, SMTP, DNS). Устройствами представления могут выступать программы: Zoom, Telegram, браузеры.

6. Представления (Presentation) layer: Преобразует данные, обеспечивает шифрование, сжатие и кодирование (форматы JPG, GIF, SSL/TLS).

Данные на этом уровне при отправке кодрируются в биты, при приеме преуоразуются из битов в привычный вид. Также можно зашифровать данные, если это необходимо.

5. Сеансовый (Session) layer: Управляет сеансами связи, устанавливает, поддерживает и завершает диалог между приложениями.

Lанные имеют привычный вид — например, JPEG- или MP3-файлов. Данный уровень позволяет нам увидеть информацию в привычном и ощутимом гля человека виде – основная задача сети на данном уровне. 
Сеантовый уровень упровляет соединениями/сессиями (пример ZOOM-звонок). На сеансовом уровне очень важно, чтобы соединение правильно установилось и поддерживалось. То есть механизмы протоколов должны проверить, что у обоих собеседников есть нужные кодеки и сигнал между устройствами присутствует.

4. Транспортный (Transport) layer: Обеспечивает доставку данных, контролирует ошибки и управляет потоком (протоколы TCP, UDP).
Оба этих протокола отвечают за то, как именно будут передаваться данные. 

- TCP (Transmission Control Protocol) — это протокол, который гарантирует доставку данных в корректном виде. Он жёстко следит за каждым битом информации, но работает гораздо медленнее UDP.
Например, при авторизации в систему, необходимо, чтобы все символы отправились в определённой последовательности. Если какие-то символы потеряются или изменятся, произойдет ошибка авторизации. Поэтому протокол TCP использует разные методы проверок — например, **контрольные суммы**.
- в видео или аудио небольшие потери некритичны, зато важна скорость передачи данных. Для таких задач как раз и придумали протокол UDP (user datagram protocol). Он уже не проверяет цельность битов, его задача — как можно быстрее передать данные с одного устройства на другое.

В протоколе TCP данные делятся на сегменты. Каждый сегмент — часть пакета. Сегменты нужны, чтобы передавать информацию по сети, учитывая её пропускную способность. Может быть компьютер с пропускной с пособностью 100 мб/с, а телефон 10 мб/с. TCP сигментирует информацию так, чтобы кажды сигмент составлял размер пропускной способности другого устройства (10 мб/с), что позволит данным перемещаться без остановки.
Также сигменты составляют надежность – большой пакет может потеряться или отпарвиться не по тому MAC-адресу, при потреле одного из сигментов пакета TCP запросит сегмент снова, а после ддоставит данные получателю.

В UDP данные делятся на датаграммы — аналогично пакетам, однако датаграммы автономны. Каждая датаграмма имеет всё необходимое, чтобы дойти до получателя. Поэтому они не зависят от сети и могут доставляться по разным маршрутам и в произвольном порядке.

3. Сетевой (Network) layer: Отвечает за маршрутизацию и логическую адресацию, выбор пути (IP-адреса, маршрутизаторы).

Маршрутизаторы используют MAC адреса для построения маршрута от одного устройства к другому. MAC-адрес расшифровывается в IP, которые представляют собой пакеты данных (в пакетах лежат IP отправителя и получаеля). 

2. Канальный (Data Link) layer: Обеспечивает передачу данных в физической сети, использует MAC-адреса (коммутаторы, Ethernet).

Проверяет целостность полученных данных и проверяет ошибки. На этом уровне утроена четка логика отличичия разных битов (нулей и единиц) благодаря разным амплитудам. Полученные данные с 1 уровня делятся на фреймы, каждый из которых состоит из служебной информации (адрес отправителя, получателя, данные и др..). 

**Структура фрейма: MAC-адрес отправителя -> MAC-адрес получаетеля -> Данные**
MAC-адрес нужен, чтобы идентифицировать устройства в локальной сети, состоит из 48 или 64 бит и выглядит примерно так: 00:1A:2B:3C:4D:5E или 00-1A-2B-3C-4D-5E. Для каждого устройства присваивают определённый MAC-адрес, который потом уже никак нельзя поменять. MAC-адрес настольных ПК зашит в сетевую карту, поэтому его можно изменить, только заменив эту самую карту. 

**Канальный уровеньделится на два подуровня:**
- уровень управления логическим каналом — LLC (logical link control);
- уровень управления доступом к среде — тот самый MAC (media access control).

      - первый подуровень нужен для взаимодействия с верхним уровнем, сетевым.
      - второй — для взаимодействия с нижним, физическим. 
      - устройства канального уровня — коммутаторы и мосты. Они нужны, чтобы передавать фреймы нужному адресату. 
      - протоколы канального уровня — PPP, CDP.

1. Физический (Physical) layer: Передает необработанные биты через физическую среду (кабели, Wi-Fi, концентраторы). Полная абстракция (ток, свет, радиоволны)

## 2. Адрессация

**Каждому компьютеру в сети присвоем свой IP (Адрес хоста)**

- IP-адрес представляет собой 32-битовое двоичное число. Удобной формой записи IP-адреса (IPv4) является запись в виде четырёх десятичных чисел (от 0 до 255), разделённых точками, например, 192.168.0.1. В общем случае, IP-адрес делится на две части: адрес сети (подсети) и адрес хоста: адрес хоста может быть разбит на подсети (с помощью маски подсети). 
- ID-сети - сеть, в которой мы находимся в общем.
- ID-хоста - наше устройство в этой сети.

**Кроме адреса хоста в сети TCP/IP есть такое понятие, как порт:**

- На одном компьютере может работать много сервисов (например, почтовый сервер, веб-сервер, файловый сервер, сервер печати и т. д.), совместно использующих один и тот же сетевой интерфейс и, следовательно, один и тот же IP-адрес.

<a id="network-interface"></a>

      Примеры сетевых интерфейсов:

      - В Linux классические имена: eth0 — проводной Ethernet‑интерфейс, wlan0 — беспроводной Wi‑Fi‑интерфейс.
      - Виртуальные: tun0/tap0 (VPN), интерфейсы виртуальных машин в облаке, которым просто назначен IP‑адрес в подсети.

      Что делает сетевой интерфейс на практике:

      - Принимает данные от операционной системы, инкапсулирует их в кадры, добавляя нужные заголовки протоколов.

      - Преобразует цифровой поток в сигнал по среде передачи (электрический, оптический, радиосигнал) и обратно при приеме.

      - Используется для настройки IP‑адреса, маски, шлюза, DNS и других параметров подключения к сети.

- Чтобы их разделить, каждый сервис прослушивает другой порт (например, `25` для электронной почты, `80` для веб-сервера и т. д.). Когда вы отправляете сообщение TCP/IP, вы должны указать IP-адрес получателя, а также порт, на котором должно быть получено сообщение.

- Порты - это логическое понятие. Физически они используют тот же кабель, что и все остальные сообщения. Это дополнительное число, закодированное в пакете TCP/IP. Когда сетевой стек операционной системы получает такое сообщение, он считывает номер порта и пересылает сообщение тому сервису, который в данный момент удерживает этот порт.

- С программной точки зрения, порт — это область памяти, которая контролируется каким-либо сервисом.

- Номера портов типа 1,2 отдаются самымм важным сервисам, менее важные получают более большие цифры.

- Протокол IP не имеет представления о портах, за интерпретацию портов отвечает TCP и UDP, по аналогии TCP и UDP не обрабатывают IP-адреса.

## 3. Маршрутизация

Для того, чтобы посылать пакеты, компьютер имеет таблицу маршрутизации и шлюзы.

## Шлюз:

Шлюз — это обычный компьютер/роутер с минимум двумя [сетевыми интерфейсами](#network-interface), каждый из которых подключен к своей сети. Он принимает пакеты из одной сети и, если нужно, пересылает их в другую, выступая «переходом» между сетями на одном компьютере. То есть передает данные между сетевыми интерфесами, если сетевые интерфейсы будут иметь одну сеть, то шлюз не нужен.

Проще: представь два разных двора (две сети) и калитку между ними — именно эта калитка и есть шлюз. Сети соединены шлюзами (маршрутизаторами). Шлюз — это тот же хост (наше устройство), но имеющий соединение с двумя и более сетями, который может передавать информацию между сетями и направлять пакеты в другую сеть
