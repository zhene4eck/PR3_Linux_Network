# Сети в Linux

## В этом проекте поставлена задача: настроить сети в Linux на виртулаьной машине.

### В рамках задачи изучается:
- Стек протоколов TCP IP
- Адресация
- Маршрутизация


## 1. Стек протоколов TCP IP

Сеть - соединеие компьютеров (2 или более) с помощью каналов связи или оборудования. Данные между компьютерами передаются (по каналам/оборудоваию) с помощью правил. Эти правила задаются стеком протоколов TCP IP. 

## 1.1. Stack
Stack – способ линейной организации данных по принципу last in first out, LIFO или «последним пришёл, первым вышел» (добавлять новые элементы и удалять существующие можно только с вершины). Чем выше элемент находится в пирамиде, тем раньше его заберут. Этим стеки отличаются от очереди (queue) — структуры данных, где первым используется элемент, который появился раньше всех.

### Команды, которые можно использовать со стеками:

- push — добавляет элемент на вершину стека.
- pop — удаляет элемент с вершины стека.
- peek — считывает элемент с вершины стека без его удаления.
- isEmpty — проверяет, пуст ли стек.
- size — возвращает количество элементов в стеке.

### Как используем:
- Реализация отмены. Можем отменить последнее созданное действие в графическом и текстовом редакторе без подъема всей цепочки последоватености (всей хронологии).
- Хранит информацию о вызовах функций и локальных переменных.
- Управление операциями в базах данных.
- Для управления вызовами системных функций и передачей параметров между приложениями и ядром операционной системы.
- Для вычисления выражений, проверки скобок и выполнения других операций.

### Реализация стека:

- С помощью динамического массива – размер которого может увеличиваться или уменьшаться в процессе выполнения программы. Операции добавления (push) и удаления (pop) элементов производятся либо с конца, либо с начала массива. Используется при фиксированном размере и нечастых изменениях стека.

- С помощью связных списков – каждый узел содержит какие-то данные и указатель на предыдущий узел. При добавлении новый элемент становится вершиной стека, а при удалении на вершине оказывается предыдущий элемент. Используем в случае, когда не знаем максимальную величину или хотим часто менять размер стека.

### Стек вызовов:

Стек вызовов — это структура данных, которая управляет вызовами функций во время выполнения программы. Когда компьютер выполняет функцию, и ему нужно переключиться на следущую, он записывает в стек точки перехода (начения переменных, аргументы функций и адрес возврата — то место, куда компьютер должен перейти после окончания подпрограммы). Когда функция выполнена, программа считывает точку перехода (адрес возврата) в стеке, удаляет ее и переходит к основной программе, выполняя ее.

### Переполение стека:

- Рекурсия большой глублины вложенности влияет на аварийное завершение работы (Python до 3000 вызовов).
- Бесконенчые циклы:

      def infinite_loop():
          while True:
              pass
      Вызываем бесконечный цикл
      infinite_loop()

### Стек данных:

Этот вид стеков часто используют для работы с разветвлёнными типами данных: деревьями, графами, XML-документами, JSON-объектами и другими.
Древо: в этом случае мы начинаем с корня и идём так глубоко, как только можем, а потом возвращаемся, чтобы исследовать другую ветвь. И стеки подходят для этого как нельзя лучше:

- Когда мы посещаем узел, мы добавляем его в стек.
- Когда мы хотим вернуться к предыдущему узлу, мы достаём его из стека.

## 1.2. Transmission Control Protocol/Internet Protocol

### **Transmission Control Protocol/Internet Protocol (TCP IP)** – стек протоколов, которые задают правиа: 

**TCP (Transmission Control Protocol)** отвечает за обмен данными. Он управляет их отправкой и следит за тем, чтобы они дошли до получателя в целости.
**IP (Internet Protocol)** отвечает за адресацию. Его задача — связывать друг с другом устройства и нарезать данные на пакеты для удобной отправки. 
Эти два протокола работают в связке: IP строит маршрут, а TCP контролирует, чтобы всё передавалось правильно.

### 7 уровней модели OSI:

Каждый протокол описывает строго ему отведенный набор правил. Также протоколы разделены по уровням функциональности (по модели сетевого взаимодействия OSI - 7 уровней). 
Модель OSI спускеются вниз от прикладного до физического уровня, передает инфомацию на другой компьютер, после подниматся обратно (на компьютере получателя и отправителя). Сначало идет шифрование и передача, а после на компьютере отправителя и получаетля расшифрование информации.

7. Прикладной (Application) layer: Обеспечивает интерфейс между пользователем и сетью (например, картинка, которую мы хотим отправить), работает с приложениями (протоколы HTTP, FTP, SMTP, DNS).

Данный уровень позволяет смотреть и пользоваться (серфить) информацией. Представлен сетевым интерфейсом (протоколы HTTP, FTP, SMTP, DNS). Устройствами представления могут выступать программы: Zoom, Telegram, браузеры.

6. Представления (Presentation) layer: Преобразует данные, обеспечивает шифрование, сжатие и кодирование (форматы JPG, GIF, SSL/TLS).

Данные на этом уровне при отправке кодрируются в биты, при приеме преуоразуются из битов в привычный вид. Также можно зашифровать данные, если это необходимо.

5. Сеансовый (Session) layer: Управляет сеансами связи, устанавливает, поддерживает и завершает диалог между приложениями.

Lанные имеют привычный вид — например, JPEG- или MP3-файлов. Данный уровень позволяет нам увидеть информацию в привычном и ощутимом гля человека виде – основная задача сети на данном уровне. 
Сеантовый уровень упровляет соединениями/сессиями (пример ZOOM-звонок). На сеансовом уровне очень важно, чтобы соединение правильно установилось и поддерживалось. То есть механизмы протоколов должны проверить, что у обоих собеседников есть нужные кодеки и сигнал между устройствами присутствует.

4. Транспортный (Transport) layer: Обеспечивает доставку данных, контролирует ошибки и управляет потоком (протоколы TCP, UDP).
Оба этих протокола отвечают за то, как именно будут передаваться данные. 

- TCP (Transmission Control Protocol) — это протокол, который гарантирует доставку данных в корректном виде. Он жёстко следит за каждым битом информации, но работает гораздо медленнее UDP.
Например, при авторизации в систему, необходимо, чтобы все символы отправились в определённой последовательности. Если какие-то символы потеряются или изменятся, произойдет ошибка авторизации. Поэтому протокол TCP использует разные методы проверок — например, **контрольные суммы**.
- в видео или аудио небольшие потери некритичны, зато важна скорость передачи данных. Для таких задач как раз и придумали протокол UDP (user datagram protocol). Он уже не проверяет цельность битов, его задача — как можно быстрее передать данные с одного устройства на другое.

В протоколе TCP данные делятся на сегменты. Каждый сегмент — часть пакета. Сегменты нужны, чтобы передавать информацию по сети, учитывая её пропускную способность. Может быть компьютер с пропускной с пособностью 100 мб/с, а телефон 10 мб/с. TCP сигментирует информацию так, чтобы кажды сигмент составлял размер пропускной способности другого устройства (10 мб/с), что позволит данным перемещаться без остановки.
Также сигменты составляют надежность – большой пакет может потеряться или отпарвиться не по тому MAC-адресу, при потреле одного из сигментов пакета TCP запросит сегмент снова, а после ддоставит данные получателю.

В UDP данные делятся на датаграммы — аналогично пакетам, однако датаграммы автономны. Каждая датаграмма имеет всё необходимое, чтобы дойти до получателя. Поэтому они не зависят от сети и могут доставляться по разным маршрутам и в произвольном порядке.

3. Сетевой (Network) layer: Отвечает за маршрутизацию и логическую адресацию, выбор пути (IP-адреса, маршрутизаторы).

Маршрутизаторы используют MAC адреса для построения маршрута от одного устройства к другому. MAC-адрес расшифровывается в IP, которые представляют собой пакеты данных (в пакетах лежат IP отправителя и получаеля). 

2. Канальный (Data Link) layer: Обеспечивает передачу данных в физической сети, использует MAC-адреса (коммутаторы, Ethernet).

Проверяет целостность полученных данных и проверяет ошибки. На этом уровне утроена четка логика отличичия разных битов (нулей и единиц) благодаря разным амплитудам. Полученные данные с 1 уровня делятся на фреймы, каждый из которых состоит из служебной информации (адрес отправителя, получателя, данные и др..). 

**Структура фрейма: MAC-адрес отправителя -> MAC-адрес получаетеля -> Данные**
MAC-адрес нужен, чтобы идентифицировать устройства в локальной сети, состоит из 48 или 64 бит и выглядит примерно так: 00:1A:2B:3C:4D:5E или 00-1A-2B-3C-4D-5E. Для каждого устройства присваивают определённый MAC-адрес, который потом уже никак нельзя поменять. MAC-адрес настольных ПК зашит в сетевую карту, поэтому его можно изменить, только заменив эту самую карту. 

**Канальный уровеньделится на два подуровня:**
- уровень управления логическим каналом — LLC (logical link control);
- уровень управления доступом к среде — тот самый MAC (media access control).

      - первый подуровень нужен для взаимодействия с верхним уровнем, сетевым.
      - второй — для взаимодействия с нижним, физическим. 
      - устройства канального уровня — коммутаторы и мосты. Они нужны, чтобы передавать фреймы нужному адресату. 
      - протоколы канального уровня — PPP, CDP.

1. Физический (Physical) layer: Передает необработанные биты через физическую среду (кабели, Wi-Fi, концентраторы). Полная абстракция (ток, свет, радиоволны)

## 2. Адрессация

**Каждому компьютеру в сети присвоем свой IP (Адрес хоста)**

Вот пример  IPv4-адреса — 193.167.22.11. Он представляет собой четыре числа (октета), разделенных точками. Длина каждого октета — 8 бит. Следовательно, общая длина адреса — 32 бита (4*8). Возможный диапазон чисел — от 0.0.0.0 до 255.255.255.255. Если посчитать, то получается, что всего можно назначить 4 294 967 296 IPv4-адресов. 

  ![alt text](/Photo/IP-адрес.png)

Разделить IP-адрес на номер сети и номер хоста поможет маска подсети (subnet mask). Как и IP-адреса, маска состоит из 32 бит (4 числа по 8 бит). Пример написания: 255.255.255.0 в десятичном формате и 11111111.11111111.11111111.00000000 — в двоичном каждое число представлено в виде восьми чисел, число (не важно, 0 или 1) = 1 бит. 1 - номера сети, 0 - номера устройств.

Маска подсети маскирует только сетевую часть (адрес сети), оставляя видимой только часть хоста. Так мы можем понять, какие устройства принадлежат одной и той же сети:

      PC1	192.168.1.10	255.255.255.0	192.168.1.0	✅ Да
      PC2	192.168.1.55	255.255.255.0	192.168.1.0	✅ Да
      PC3	192.168.2.20	255.255.255.0	192.168.2.0	❌ Нет

      192.168.1.10 и 192.168.1.55 имеют одинаковый номер сети 192.168.1.0, поэтому находятся в одной подсети и могут общаться напрямую. 192.168.2.20 — в другой подсети (192.168.2.0).

### Префиксная нотация:

Колличество свободных подсетей и хостов можно определить благодаря префиксу, например ``/16``. Вместо использования маски подсети в десятичной записи (``255.255.255.0``), в CIDR маска подсети значится в виде числа (``/23``), указывающего на количество битов в сетевой части IP-адреса.

      Как работает префиксная нотация:

      - Префикс /24 означает, что первые 24 бита (3 числа по 8 бит) из 32 бит IP-адреса принадлежат сети, а оставшиеся 8 бит предназначены для хостов. Маска подсети — 255.255.255.0.

      - Префикс /16 означает, что первые 16 бит (2 числа по 8 бит) из 32 бит принадлежат сети. Маска подсети — 255.255.0.0.

      - Префикс /8 означает, что сети принадлежат первые 8 бит (1 число). Маска подсети — 255.0.0.0.

**Пример расчетов**

      Разделим сеть 192.168.1.0 с маской /24 (255.255.255.0) на 8 подсетей. Определяем, сколько бит потребуется. Для 8 подсетей нужно выделить 3 бита (2^3 = 8). Добавляем 3 бита к маске /24 и получаем маску /27 (255.255.255.224). Откуда получили ``32`` для диапазона ниже: 32 бит - 27 бит (27 бит наша новая маска, так как мы поделили сеть с маской 24 на 8 подсетей) = 5 бит предназначены для хостов (2^5 = 32). Получаем 32 бит для каждого диапазона (у нас их 8).
      
      Определяем диапазоны:

      Сеть 1: 192.168.1.0/27 → Диапазон: 192.168.1.0 — 192.168.1.31.

      Сеть 2: 192.168.1.32/27 → Диапазон: 192.168.1.32 — 192.168.1.63.

      Сеть 3: 192.168.1.64/27 → Диапазон: 192.168.1.64 — 192.168.1.95.

      Сеть 4: 192.168.1.96/27 → Диапазон: 192.168.1.96 — 192.168.1.127.

      Сеть 5: 192.168.1.128/27 → Диапазон: 192.168.1.128 — 192.168.1.159.

      Сеть 6: 192.168.1.160/27 → Диапазон: 192.168.1.160 — 192.168.1.191.

      Сеть 7: 192.168.1.192/27 → Диапазон: 192.168.1.192 — 192.168.1.223.

      Сеть 8: 192.168.1.224/27 → Диапазон: 192.168.1.224 — 192.168.1.255.


      Определяем количество бит для хостов: 32 - 27 = 5 бит для хостов. Рассчитываем количество адресов: 2^5 -2 = 32 - 2. Получается 30 хостов.

      Дальше определяем доступные адреса для хостов. Например, для подсети 192.168.1.0/27 это адреса от 192.168.1.1 до 192.168.1.30. Адрес 192.168.1.0 — адрес самой подсети, а 192.168.1.31 — широковещательный адрес.

      ДЕЛАЮ ВЫВОД: если маска состоит из 255 или 0 или префикс кратен 8, то подсетей нет. Если в маске написана каша или префик не кратен 8, то есть подсети.

      РАСПИСАТЬ ЧЕК ЛИСТ, ЧТО МЫ ДЕЛАЕМ, ЧТОБЫ РАЗДЕЛИТЬ СЕТЬ НА СЕОЛЬКО-ТО ПОДСЕТЕЙ И ПОСЧИТАТЬ, СКОЛЬКО ХОСТОВ МОЖНО ВЫДЕЛИТЬ!!!

- IP-адрес представляет собой 32-битовое двоичное число. Удобной формой записи IP-адреса (IPv4) является запись в виде четырёх десятичных чисел (от 0 до 255), разделённых точками, например, 192.168.0.1. В общем случае, IP-адрес делится на две части: адрес сети (подсети) и адрес хоста: адрес хоста может быть разбит на подсети (с помощью маски подсети). 
- ID-сети - сеть, в которой мы находимся в общем.
- ID-хоста - наше устройство в этой сети.

**Кроме адреса хоста в сети TCP/IP есть такое понятие, как порт:**

- На одном компьютере может работать много сервисов (например, почтовый сервер, веб-сервер, файловый сервер, сервер печати и т. д.), совместно использующих один и тот же сетевой интерфейс и, следовательно, один и тот же IP-адрес.

<a id="network-interface"></a>

      Примеры сетевых интерфейсов:

      - В Linux классические имена: eth0 — проводной Ethernet‑интерфейс, wlan0 — беспроводной Wi‑Fi‑интерфейс.
      - Виртуальные: tun0/tap0 (VPN), интерфейсы виртуальных машин в облаке, которым просто назначен IP‑адрес в подсети.

      Что делает сетевой интерфейс на практике:

      - Принимает данные от операционной системы, инкапсулирует их в кадры, добавляя нужные заголовки протоколов.

      - Преобразует цифровой поток в сигнал по среде передачи (электрический, оптический, радиосигнал) и обратно при приеме.

      - Используется для настройки IP‑адреса, маски, шлюза, DNS и других параметров подключения к сети.

- Чтобы их разделить, каждый сервис прослушивает другой порт (например, `25` для электронной почты, `80` для веб-сервера и т. д.). Когда вы отправляете сообщение TCP/IP, вы должны указать IP-адрес получателя, а также порт, на котором должно быть получено сообщение.

- Порты - это логическое понятие. Физически они используют тот же кабель, что и все остальные сообщения. Это дополнительное число, закодированное в пакете TCP/IP. Когда сетевой стек операционной системы получает такое сообщение, он считывает номер порта и пересылает сообщение тому сервису, который в данный момент удерживает этот порт.

- С программной точки зрения, порт — это область памяти, которая контролируется каким-либо сервисом.

- Номера портов типа 1,2 отдаются самымм важным сервисам, менее важные получают более большие цифры.

- Протокол IP не имеет представления о портах, за интерпретацию портов отвечает TCP и UDP, по аналогии TCP и UDP не обрабатывают IP-адреса.

## 3. Маршрутизация

Для того, чтобы посылать пакеты, компьютер имеет таблицу маршрутизации и шлюзы.

### Шлюз:

Шлюз — это обычный компьютер/роутер с минимум двумя [сетевыми интерфейсами](#network-interface), каждый из которых подключен к своей сети. Он принимает пакеты из одной сети и, если нужно, пересылает их в другую, выступая «переходом» между сетями на одном компьютере. То есть передает данные между сетевыми интерфесами, если сетевые интерфейсы будут иметь одну сеть, то шлюз не нужен.

Проще: представь два разных двора (две сети) и калитку между ними — именно эта калитка и есть шлюз. Сети соединены шлюзами (маршрутизаторами). Шлюз — это тот же хост (наше устройство), но имеющий соединение с двумя и более сетями, который может передавать информацию между сетями и направлять пакеты в другую сеть

### Как IP решает, куда отправить пакет:

У каждого IP‑пакета есть адрес назначения, который делится маской на две части: сетевая часть и хостовая часть. Сетевая часть говорит, в какую сеть нужно доставить пакет. Хостовая часть говорит, какому конкретно устройству в этой сети он адресован. IP на хосте не думает «как попасть к конкретному компьютеру в Интернете», он сперва думает «в какую сеть мне отправить этот пакет дальше».

### Таблица маршрутизаци

На каждом хосте есть таблица маршрутизации — список правил вида: «для такой‑то сети используй такой‑то шлюз (или интерфейс)». 
Упрощённо в таблице могут быть такие строки:

- Сеть 192.168.1.0/24 — отправлять прямо в локальную сеть (без шлюза).

- Сеть 10.0.0.0/24 — отправлять на шлюз 192.168.1.1.

- Остальные адреса — отправлять на шлюз по умолчанию 192.168.1.254.

Когда твой компьютер хочет отправить пакет:

- Смотрит на IP‑адрес назначения.

- Маской выделяет его сетевую часть.

- Сравнивает сетевую часть с записями в таблице маршрутизации.

- Если находит подходящую запись — отправляет пакет либо напрямую (если сеть локальная), либо на указанный шлюз (маршрутизатор).

- Если подходящей записи нет — использует маршрут по умолчанию (default gateway).

      В Linux ядро операционной системы хранит таблицу маршрутизации в файле /proc/net/route. Просмотреть текущую таблицу маршрутизации можно командой netstat -rn (r — routing table, n — не преобразовывать IP в имена), route или ip r.

Ниже приведен типичный вывод команды netstat -rn (или ip r):
Пример таблицы маршрутизации для хоста eggplant:

      [root@eggplant ~]# netstat -rn
      Kernel IP routing table
      Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
      128.17.75.0     128.17.75.20    255.255.255.0   U         0 0          0 eth0
      128.17.75.0     0.0.0.0         255.255.255.0   U         0 0          0 eth0
      127.0.0.0       127.0.0.1       255.0.0.0       UG        0 0          0 lo
      0.0.0.0         128.17.75.98    0.0.0.0         UG        0 0          0 eth0

**Значения колонок:**

- Destination — адреса сетей (хостов) назначения. При этом, при указании сети, адрес обычно заканчивается на ноль;
- Gateway — адрес шлюза для указанного в первой колонке хоста/сети. Третья колонка — маска подсети, для которой работает данный маршрут;
- Flags — информация об адресе назначения (U — маршрут работает, N — маршрут для сети, H — маршрут для хоста и т. п.);
- MSS — число байтов, которое может быть отправлено за 1 раз;
- Window — количество фреймов, которое может быть отправлено до получения подтверждения;
- irtt — статистика использования маршрута;
- Iface — указывает сетевой интерфейс, используемый для маршрута (eth0, eth1 и т. п.).

